-- Khuyến nghị: bật extension citext để so sánh username không phân biệt hoa/thường
CREATE EXTENSION IF NOT EXISTS citext;

-- Kiểu ENUM (tuỳ chọn; có thể thay bằng CHECK nếu bạn muốn)
DO $$
BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'loai_biendong_enum') THEN
    CREATE TYPE loai_biendong_enum AS ENUM ('tam_tru','tam_vang');
  END IF;
  IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'trang_thai_dotthu_enum') THEN
    CREATE TYPE trang_thai_dotthu_enum AS ENUM ('draft','open','closed');
  END IF;
  IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'trang_thai_taikhoan_enum') THEN
    CREATE TYPE trang_thai_taikhoan_enum AS ENUM ('Đang hoạt động', 'Ngừng hoạt động');
  END IF;
END$$;

-- 1) VaiTro
CREATE TABLE vaitro (
  id_vaitro   INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  ten_vaitro  VARCHAR(50) NOT NULL
);

-- 2) TaiKhoan
CREATE TABLE taikhoan (
  id_taikhoan INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  username    CITEXT NOT NULL UNIQUE,
  password    VARCHAR(255) NOT NULL,
  id_vaitro   INT NOT NULL REFERENCES vaitro(id_vaitro) ON UPDATE RESTRICT ON DELETE RESTRICT,
  trang_thai  trang_thai_taikhoan_enum NOT NULL DEFAULT 'Đang hoạt động'
);

-- 3) HoKhau
CREATE TABLE hokhau (
  id_hokhau  INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  so_can_ho  VARCHAR(20) NOT NULL UNIQUE,
  dien_tich  DOUBLE PRECISION
);

-- 4) NhanKhau
CREATE TABLE nhankhau (
  id_nhankhau       INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  ho_ten            VARCHAR(100) NOT NULL,
  ngay_sinh         DATE,
  cccd              VARCHAR(12) UNIQUE,
  quan_he_chu_ho    VARCHAR(50),
  id_hokhau         INT NOT NULL REFERENCES hokhau(id_hokhau) ON UPDATE RESTRICT ON DELETE RESTRICT,
  -- kiểm tra CCCD: đúng 12 ký tự số (cho phép NULL)
  CONSTRAINT cccd_format_chk CHECK (cccd IS NULL OR cccd ~ '^[0-9]{12}$')
);

CREATE INDEX idx_nhankhau_hokhau ON nhankhau(id_hokhau);

-- 5) BienDongNhanKhau
CREATE TABLE biendongnhankhau (
  id_biendong  INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  loai_biendong loai_biendong_enum NOT NULL,       -- 'tam_tru' | 'tam_vang'
  ngay_batdau  DATE NOT NULL,
  ngay_ketthuc DATE,
  ly_do        TEXT,
  id_nhankhau  INT NOT NULL REFERENCES nhankhau(id_nhankhau) ON UPDATE RESTRICT ON DELETE CASCADE,
  CONSTRAINT ngay_bd_truoc_kt CHECK (ngay_ketthuc IS NULL OR ngay_ketthuc >= ngay_batdau)
);

CREATE INDEX idx_biendong_nhankhau ON biendongnhankhau(id_nhankhau);

-- 6) KhoanThu
CREATE TABLE khoanthu (
  id_khoanthu   INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  ten_khoanthu  VARCHAR(100) NOT NULL,
  don_gia       NUMERIC(15,2) NOT NULL CHECK (don_gia >= 0),
  don_vi_tinh   VARCHAR(20) NOT NULL
);

-- 7) DotThuPhi
CREATE TABLE dotthuphi (
  id_dotthu    INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  ten_dotthu   VARCHAR(100) NOT NULL,
  ngay_batdau  DATE NOT NULL,
  ngay_ketthuc DATE,
  trang_thai   trang_thai_dotthu_enum DEFAULT 'draft',
  id_khoanthu  INT NOT NULL REFERENCES khoanthu(id_khoanthu) ON UPDATE RESTRICT ON DELETE RESTRICT,
  CONSTRAINT dotthu_time_chk CHECK (ngay_ketthuc IS NULL OR ngay_ketthuc >= ngay_batdau)
);

CREATE INDEX idx_dotthu_khoanthu ON dotthuphi(id_khoanthu);

-- 8) HoaDon
CREATE TABLE hoadon (
  id_hoadon  INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  tong_tien  NUMERIC(15,2) NOT NULL CHECK (tong_tien >= 0),
  ngay_nop   DATE,
  id_hokhau  INT NOT NULL REFERENCES hokhau(id_hokhau) ON UPDATE RESTRICT ON DELETE RESTRICT,
  id_dotthu  INT NOT NULL REFERENCES dotthuphi(id_dotthu) ON UPDATE RESTRICT ON DELETE RESTRICT,
  -- mỗi hộ chỉ có 1 hóa đơn cho 1 đợt
  CONSTRAINT uq_hoadon_hokhau_dotthu UNIQUE (id_hokhau, id_dotthu)
);

CREATE INDEX idx_hoadon_hokhau ON hoadon(id_hokhau);
CREATE INDEX idx_hoadon_dotthu  ON hoadon(id_dotthu);

-- (tuỳ chọn) vài chú thích cột để team dễ đọc trong pgAdmin
COMMENT ON COLUMN hoadon.tong_tien IS 'Có thể để ứng dụng tính theo don_gia * đơn vị tính (m2/người) + rule riêng rồi ghi vào đây';
COMMENT ON COLUMN nhankhau.quan_he_chu_ho IS 'Ví dụ: Chu ho, Vo/Chong, Con, ...';

-- INDEX & TRIGGER
-- INDEX ---------------------------------------------------------------------------------
-- =========== TẠO INDEX (ĐỂ TĂNG TỐC TRUY VẤN) ===========

-- 1. TẠO INDEX CHO CÁC KHÓA NGOẠI (BẮT BUỘC)
-- --------------------------------------------------
-- Tăng tốc khi tìm tài khoản theo vai trò
CREATE INDEX idx_fk_taikhoan_vaitro ON taithoan(id_vaitro);

-- Tăng tốc khi tìm nhân khẩu theo hộ khẩu
CREATE INDEX idx_fk_nhankhau_hokhau ON nhankhau(id_hokhau);

-- Tăng tốc khi tìm biến động theo nhân khẩu
CREATE INDEX idx_fk_biendong_nhankhau ON biendongnhankhau(id_nhankhau);

-- Tăng tốc khi tìm đợt thu theo khoản thu (Quan hệ 1-N của bạn)
CREATE INDEX idx_fk_dotthuphi_khoanthu ON dotthuphi(id_khoanthu);

-- Tăng tốc khi tìm hóa đơn theo hộ khẩu
CREATE INDEX idx_fk_hoadon_hokhau ON hoadon(id_chuho); -- 'id_chuho' là FK trỏ đến HoKhau

-- Tăng tốc khi tìm hóa đơn theo đợt thu
CREATE INDEX idx_fk_hoadon_dotthuphi ON hoadon(id_dotthu);

-- Tăng tốc khi tìm tài khoản theo vai trò
CREATE INDEX idx_taikhoan_vaitro ON taikhoan(id_vaitro);

-- Tăng tốc nghiệp vụ "Tìm kiếm nhân khẩu" của Tổ trưởng
CREATE INDEX idx_nhankhau_hoten ON nhankhau(ho_ten);

-- Tăng tốc nghiệp vụ "Lọc đợt thu" của Kế toán
CREATE INDEX idx_dotthuphi_trangthai ON dotthuphi(trang_thai);

-- TRIGGER ---------------------------------------------------------------------------------
-- Chức năng: Đảm bảo ten_vaitro chỉ có thể là 'Tổ trưởng', 'Tổ phó', hoặc 'Kế toán'.
-- Bước 1.1: Tạo hàm (FUNCTION) chứa logic
CREATE OR REPLACE FUNCTION fn_check_vaitro_ten()
RETURNS TRIGGER AS $$
BEGIN
    -- Kiểm tra xem ten_vaitro mới (NEW.ten_vaitro) có nằm trong danh sách cho phép không
    IF NEW.ten_vaitro NOT IN ('Tổ trưởng', 'Tổ phó', 'Kế toán') THEN
        -- Nếu không, hủy bỏ hành động và báo lỗi
        RAISE EXCEPTION 'Lỗi: Tên vai trò không hợp lệ. Chỉ chấp nhận: Tổ trưởng, Tổ phó, Kế toán.';
    END IF;
    
    -- Nếu hợp lệ, cho phép hành động (INSERT hoặc UPDATE) tiếp tục
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Bước 1.2: Tạo Trigger để "gắn" hàm vào bảng
-- Trigger này chạy cho cả INSERT (1.1) và UPDATE (1.2)
CREATE TRIGGER trg_check_vaitro_ten
BEFORE INSERT OR UPDATE ON vaitro
FOR EACH ROW
EXECUTE FUNCTION fn_check_vaitro_ten();

-- Chức năng: Đảm bảo dien_tich (m2) không phải là số âm.
-- Bước 3.1: Tạo hàm (FUNCTION) chứa logic
CREATE OR REPLACE FUNCTION fn_check_hokhau_dien_tich()
RETURNS TRIGGER AS $$
BEGIN
    -- Kiểm tra xem dien_tich mới (NEW.dien_tich) có bị âm không
    -- (Dùng IFNULL hoặc COALESCE để xử lý trường hợp giá trị là NULL một cách an toàn)
    IF COALESCE(NEW.dien_tich, 0) < 0 THEN
        -- Nếu âm, hủy bỏ hành động và báo lỗi
        RAISE EXCEPTION 'Lỗi: Diện tích (dien_tich) không được là số âm.';
    END IF;
    
    -- Nếu hợp lệ (lớn hơn hoặc bằng 0, hoặc NULL), cho phép hành động tiếp tục
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Bước 3.2: Tạo Trigger để "gắn" hàm vào bảng
-- Trigger này chạy cho cả INSERT (3.1) và UPDATE (3.2)
CREATE TRIGGER trg_check_hokhau_dien_tich
BEFORE INSERT OR UPDATE ON hokhau
FOR EACH ROW
EXECUTE FUNCTION fn_check_hokhau_dien_tich();

-- Chức năng: Đảm bảo ngay_sinh không phải là một ngày trong tương lai (không lớn hơn ngày hiện tại).
-- Bước 4.1: Tạo hàm (FUNCTION) chứa logic
CREATE OR REPLACE FUNCTION fn_check_nhankhau_ngay_sinh()
RETURNS TRIGGER AS $$
BEGIN
    -- Chỉ kiểm tra nếu ngay_sinh không rỗng (NOT NULL)
    -- và lớn hơn ngày hiện tại (CURRENT_DATE)
    IF NEW.ngay_sinh IS NOT NULL AND NEW.ngay_sinh > CURRENT_DATE THEN
        -- Nếu ở tương lai, hủy bỏ hành động và báo lỗi
        RAISE EXCEPTION 'Lỗi: Ngày sinh không hợp lệ (không được ở tương lai).';
    END IF;
    
    -- Nếu hợp lệ, cho phép hành động (INSERT hoặc UPDATE) tiếp tục
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Bước 4.2: Tạo Trigger để "gắn" hàm vào bảng
-- Trigger này chạy cho cả INSERT (4.1) và UPDATE (4.2)
CREATE TRIGGER trg_check_nhankhau_ngay_sinh
BEFORE INSERT OR UPDATE ON nhankhau
FOR EACH ROW
EXECUTE FUNCTION fn_check_nhankhau_ngay_sinh();

-- Chức năng: Đảm bảo don_vi_tinh chỉ có thể là 'm2', 'hộ', hoặc 'người'.
-- Bước 6.1: Tạo hàm (FUNCTION) chứa logic
CREATE OR REPLACE FUNCTION fn_check_khoanthu_don_vi_tinh()
RETURNS TRIGGER AS $$
BEGIN
    -- Kiểm tra xem don_vi_tinh mới (NEW.don_vi_tinh) có nằm trong danh sách cho phép không
    IF NEW.don_vi_tinh NOT IN ('m2', 'hộ', 'người') THEN
        -- Nếu không, hủy bỏ hành động và báo lỗi
        RAISE EXCEPTION 'Lỗi: Đơn vị tính không hợp lệ. Chỉ chấp nhận: m2, hộ, người.';
    END IF;
    
    -- Nếu hợp lệ, cho phép hành động (INSERT hoặc UPDATE) tiếp tục
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Bước 6.2: Tạo Trigger để "gắn" hàm vào bảng
-- Trigger này chạy cho cả INSERT (6.1) và UPDATE (6.2)
CREATE TRIGGER trg_check_khoanthu_don_vi_tinh
BEFORE INSERT OR UPDATE ON khoanthu
FOR EACH ROW
EXECUTE FUNCTION fn_check_khoanthu_don_vi_tinh();

-- Chức năng: Đảm bảo ngay_nop (nếu có) không sớm hơn ngay_batdau của DotThuPhi tương ứng.
-- Bước 10.1: Tạo hàm (FUNCTION) chứa logic
CREATE OR REPLACE FUNCTION fn_check_hoadon_ngay_nop()
RETURNS TRIGGER AS $$
DECLARE
    dtp_ngay_batdau DATE;
BEGIN
    -- Chỉ kiểm tra nếu ngay_nop (NEW.ngay_nop) được cung cấp (không rỗng)
    IF NEW.ngay_nop IS NOT NULL THEN
        -- 1. Lấy ngày bắt đầu của Đợt thu phí liên quan
        SELECT ngay_batdau INTO dtp_ngay_batdau
        FROM dotthuphi
        WHERE id_dotthu = NEW.id_dotthu;
        
        -- 2. So sánh
        IF NEW.ngay_nop < dtp_ngay_batdau THEN
            -- Nếu ngày nộp sớm hơn, hủy bỏ hành động và báo lỗi
            RAISE EXCEPTION 'Lỗi: Ngày nộp hóa đơn (%.%) không thể sớm hơn ngày bắt đầu đợt thu (%.%)', NEW.ngay_nop, dtp_ngay_batdau;
        END IF;
    END IF;
    
    -- Nếu hợp lệ (hoặc ngay_nop là NULL), cho phép hành động tiếp tục
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Bước 10.2: Tạo Trigger để "gắn" hàm vào bảng
-- Trigger này chạy cho cả INSERT (10.1) và UPDATE (10.2)
CREATE TRIGGER trg_check_hoadon_ngay_nop
BEFORE INSERT OR UPDATE ON hoadon
FOR EACH ROW
EXECUTE FUNCTION fn_check_hoadon_ngay_nop();

-- Chức năng: Đảm bảo một HoKhau chỉ có một NhanKhau duy nhất có quan_he_chu_ho là 'Là chủ hộ'.
-- Bước 11.1: Tạo hàm (FUNCTION) chứa logic
CREATE OR REPLACE FUNCTION fn_check_nhankhau_chuho_unique()
RETURNS TRIGGER AS $$
DECLARE
    existing_chuho_count INT;
BEGIN
    -- Chỉ kiểm tra nếu giá trị MỚI là 'Là chủ hộ'
    IF NEW.quan_he_chu_ho = 'Là chủ hộ' THEN
        
        -- Đếm xem có ai KHÁC trong hộ đã là chủ hộ chưa
        -- TG_OP = 'INSERT' hoặc 'UPDATE' là biến hệ thống cho biết loại hành động
        IF TG_OP = 'INSERT' THEN
            SELECT COUNT(*) INTO existing_chuho_count
            FROM nhankhau
            WHERE id_hokhau = NEW.id_hokhau AND quan_he_chu_ho = 'Là chủ hộ';
        ELSIF TG_OP = 'UPDATE' THEN
            -- Khi UPDATE, chỉ kiểm tra nếu thay đổi thành 'Là chủ hộ'
            -- và loại trừ chính bản ghi đang được cập nhật
            IF OLD.quan_he_chu_ho != 'Là chủ hộ' THEN
                SELECT COUNT(*) INTO existing_chuho_count
                FROM nhankhau
                WHERE id_hokhau = NEW.id_hokhau 
                  AND quan_he_chu_ho = 'Là chủ hộ'
                  AND id_nhankhau != NEW.id_nhankhau;
            END IF;
        END IF;

        -- Nếu đã có (count > 0), báo lỗi
        IF COALESCE(existing_chuho_count, 0) > 0 THEN
            RAISE EXCEPTION 'Lỗi: Hộ khẩu này đã có chủ hộ. Vui lòng thay đổi chủ hộ cũ trước.';
        END IF;
    END IF;
    
    -- Cho phép hành động tiếp tục
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Bước 11.2: Tạo Trigger để "gắn" hàm vào bảng
-- Trigger này chạy cho cả INSERT (11.1) và UPDATE (11.2)
CREATE TRIGGER trg_check_nhankhau_chuho_unique
BEFORE INSERT OR UPDATE ON nhankhau
FOR EACH ROW
EXECUTE FUNCTION fn_check_nhankhau_chuho_unique();

-- Chức năng: Ngăn chặn DELETE một NhanKhau nếu họ đang có quan_he_chu_ho là 'Là chủ hộ'.
-- Bước 14.1: Tạo hàm (FUNCTION) chứa logic
CREATE OR REPLACE FUNCTION fn_check_delete_nhankhau_chuho()
RETURNS TRIGGER AS $$
BEGIN
    -- Kiểm tra xem người sắp bị xóa (OLD) có phải là 'Là chủ hộ' không
    IF OLD.quan_he_chu_ho = 'Là chủ hộ' THEN
        -- Nếu đúng, hủy bỏ hành động DELETE và báo lỗi
        RAISE EXCEPTION 'Lỗi: Không thể xóa. Người này đang "Là chủ hộ". Vui lòng thay đổi chủ hộ trước.';
    END IF;
    
    -- Cho phép hành động (DELETE) tiếp tục
    -- (Lưu ý: Trigger BEFORE DELETE trả về OLD khi thành công)
    RETURN OLD;
END;
$$ LANGUAGE plpgsql;

-- Bước 14.2: Tạo Trigger để "gắn" hàm vào bảng
-- Trigger này chỉ chạy khi DELETE (14)
CREATE TRIGGER trg_check_delete_nhankhau_chuho
BEFORE DELETE ON nhankhau
FOR EACH ROW
EXECUTE FUNCTION fn_check_delete_nhankhau_chuho();

-- Chức năng: Tự động kiểm tra và ngăn chặn nếu ngay_batdau của biến động sớm hơn ngay_sinh của NhanKhau tương ứng.
-- Bước 17.1: Tạo hàm (FUNCTION) chứa logic
CREATE OR REPLACE FUNCTION fn_check_biendong_vs_ngaysinh()
RETURNS TRIGGER AS $$
DECLARE
    nk_ngay_sinh DATE;
BEGIN
    -- 1. Lấy ngày sinh của nhân khẩu liên quan (từ bảng nhankhau)
    SELECT ngay_sinh INTO nk_ngay_sinh
    FROM nhankhau
    WHERE id_nhankhau = NEW.id_nhankhau;
    
    -- 2. Chỉ kiểm tra nếu nhân khẩu đó có ngày sinh (không rỗng)
    IF nk_ngay_sinh IS NOT NULL THEN
        -- 3. So sánh và báo lỗi nếu ngày bắt đầu biến động sớm hơn ngày sinh
        IF NEW.ngay_batdau < nk_ngay_sinh THEN
            RAISE EXCEPTION 'Lỗi: Ngày bắt đầu biến động (%) không thể sớm hơn ngày sinh (%).', NEW.ngay_batdau, nk_ngay_sinh;
        END IF;
    END IF;
    
    -- Nếu hợp lệ, cho phép hành động (INSERT) tiếp tục
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Bước 17.2: Tạo Trigger để "gắn" hàm vào bảng
-- Trigger này chỉ chạy khi INSERT (17)
CREATE TRIGGER trg_check_biendong_vs_ngaysinh
BEFORE INSERT ON biendongnhankhau
FOR EACH ROW
EXECUTE FUNCTION fn_check_biendong_vs_ngaysinh();

-- Chức năng: Sau khi một NhanKhau mới được INSERT thành công, tự động tạo một bản ghi 'Tạm trú' cho họ trong bảng BienDongNhanKhau.
-- Bước 18.1: Tạo hàm (FUNCTION) chứa logic
CREATE OR REPLACE FUNCTION fn_auto_create_tam_tru()
RETURNS TRIGGER AS $$
BEGIN
    -- Tự động chèn một bản ghi 'Tạm trú' cho nhân khẩu mới (NEW)
    -- Lưu ý: Dùng 'tam_tru' (không dấu) để khớp với ENUM 'loai_biendong_enum'
    INSERT INTO biendongnhankhau (loai_biendong, ngay_batdau, ly_do, id_nhankhau)
    VALUES (
        'tam_tru',        -- Giá trị từ 'loai_biendong_enum'
        CURRENT_DATE,     -- Ngày bắt đầu (lấy ngày hiện tại)
        'Đăng ký nhân khẩu mới', -- Lý do
        NEW.id_nhankhau   -- ID của nhân khẩu vừa được tạo
    );
    
    -- Trigger AFTER INSERT thường trả về NULL
    RETURN NULL;
END;
$$ LANGUAGE plpgsql;

-- Bước 18.2: Tạo Trigger để "gắn" hàm vào bảng
-- Trigger này chạy SAU KHI INSERT (18)
CREATE TRIGGER trg_auto_create_tam_tru
AFTER INSERT ON nhankhau
FOR EACH ROW
EXECUTE FUNCTION fn_auto_create_tam_tru();